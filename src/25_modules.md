При подключении обычного header-файла он просто копируется по месту включения. В связи с этим возникают __следующие проблемы__:

* Дублирование кода - если написал определение в .cpp, то будь добр написать объявление в .h, так как не разделяя код можно получить много проблем
* Нарушение ODR
* Зависимость от макросов, определенных в момент подключения .h
* Медленная компиляция (подстановка .h целиком в каждый .cpp файл, где он инклудится)

##### Рассмотрим пример

foo2.cppm
```cpp
export module K;

export int sqr(int x) {
	return x * x;
}
```

foo.cppm
```cpp
export module M;
import K;

export int f(int x) {
	return 2 + sqr(x);
}
export double g(double y, int z) {
	return y * z;
}
```

bar.cpp
```cpp
import M;
import K;

int main() {
	sqr(f(5));
	g(0., 1.);
	return 0;
}
```

С модулями появляются новые ключевые слова. Используйте ```export```, чтобы отметить в модулях, какие декларации вы хотите сделать доступными извне. Нераскрытые с помощью этого слова декларации видны извне не будут.

```export module M;``` определяет именованный модуль.

Используйте ```import``` для импортирования модуля. Импорт модуля подразумевает импортирование всего, что модуль экспортирует. В отличие от ```#include```, при импорте нужна точка с запятой.

В данном примере при компиляции сначала соберется модуль foo2.cppm (он не имеет зависимостей), затем foo.cppm (зависит от foo2.cppm), и только потом bar.cpp. Появляется новый термин ```предкомпиляция```, так как модули перед включением необходимо перевести в бинарный аналог .h.

Предкомпиляция происходит в формат .pcm (такие названия clang придумал кста, в других компиляторах расширения другие). В нем будут присутствовать все экспортированные функции, классы, шаблоны и не только, без потерь. В реализации clang файл .pcm включает в себя AST (который теперь считается всего один раз, а не при каждом включении в единицу трансляции, как это было раньше).

Сам по себе какой-нибудь модуль M может делиться на две части, подобно .h и .cpp, на Interface Unit и Implementation Unit.

```Interface Unit``` может выглядеть так:

```cpp
export module M;

export int f();
```

Тогда ```Implementation Unit``` - вот так:

```cpp
module M;

int f() {
	return 42;
}
```

Правда зачем это нужно я не знаю :(

##### Какие проблемы модули решают

* Контроль видимости имен
* Контроль зависимостей между компонентами
* Модули ускоряют процесс сборки (относительно)
* Можем не писать отдельно .cpp и .h
* Не портим код других модулей макросами при импорте
* Уменьшаем количество ошибок ODR

Модули предкомпилируются в состоянии "песочницы" - макросы из модулей экспортируются, но в другие модули они не попадают.

Вместе с тем модули нарушают несколько устоявшихся принципов С++

* Принцип независимости сборки. До модулей программу можно было скомпилировать отдельно по кусочкам, а потом слинковать все вместе - главное, чтобы заголовочные файлы были доступны. Теперь порядок не произвольный. Файл нельзя собрать, пока не предкомпилированы модули, от которых он зависит. Процесс сборки несколько усложняется. Ухудшаем распараллеливание сборки.
* ```#include``` можно было писать в любом месте программы (не только в начале, это просто договоренность), а ключевое слово ```import``` можно писать только в начале (преамбула), чтобы индексация была быстрой, но перед этим разрешается писать директивы препроцессора (например тот же ```#include```). Чтобы точнее понять, что можно, а что нельзя гуглите про преамбулу и Global module fragment.

##### Что можно импортировать в модулях и .cpp

```cpp
import M;
import "header.h";
import <my_lib>
```

Да, можно импортировать не только модули, но и заголовочные файлы. Правда с последним у компиляторов пока проблемы. Чтобы импортировать .h, его нужно предкомпилировать, что, вроде как, не очень тривиально.

##### Что можно экспортировать в модулях

```cpp
export module M;

export template <typename T>
struct Pair {
	T a, b;
}

export int f();
int f() {
	return 42;
}

export int global_var = 42;

export namespace { // i'm not sure how it should work
	int foo = 42;
}

namespace A { // exported
	export int f(); // exported
	int g(); // not exported
}

export import K; // I export everything that K exports
```

##### Tricky case

Даже если декларация не была экспортирована, она может быть использована в экспортируемых шаблонах.

```cpp
export module M;

export void foo(int);
void foo(char); // can be called anyway

template <typename T>
export void bar(T t) {
	foo(t);
}
```

```cpp
import M;

void foo(...); // fallback

int main() {
	bar(0);
}
```

Под конец, ```import``` и ```module``` - это контекстно-зависимые слова, так как во многих компаниях они уже используются. MSVC уже переписали std под модули в каком-то виде.
